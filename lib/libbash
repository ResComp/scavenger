#!/bin/bash

SubmitPipe="$DATADIR/submit"
RunDir="$DATADIR/run"

Text() {
    setting="$1" # "0" = bold, "1" = blue, "2" = red
    message=$2

    normal=$(tput sgr0)
    different=$(tput bold)
    if [ "$setting" = "1" ]; then
        different="${different}$(tput setaf 4)"
    elif [ "$setting" = "2" ]; then
        different="${different}$(tput setaf 1)"
    elif [ "$setting" = "3" ]; then
        different=$normal
    fi

    echo -n -e "${different}${message}${normal}"
}

Announce() {
    Text "$1" "\n${2}\n\n"
}

# This takes as input the name of the pid file. Not the path.
# The second argument is the pid of the process.
CreatePIDFile() {
    pidFileName=$1
    pid=$2

    pidFile="$RunDir/$pidFileName"
    install -m 600 -T /dev/null "$pidFile"
    echo $pid > "$pidFile"
}

# This takes as input the name of the pid file. Not the path.
#
# Exit code of 0 if the process is running, non-zero otherwise.
ProcessIsRunning() {
    pidFileName=$1

    pidFile="$RunDir/$pidFileName"
    # Open the pid file only if it exists
    if [ -f "$pidFile" ]; then
        pid=$(cat "$pidFile")
        if [ -n "$pid" ]; then
            if [ -e "/proc/$pid" ]; then
                return 0
            fi
        fi
    fi
    return 1
}

# Retrieve the PID from a pid file
PIDFromFile() {
    pidFileName=$1

    cat "$RunDir/$pidFileName"
}

# Retrieve the path of the pid file from the name
PIDFilePath() {
    pidFileName=$1

    echo "$RunDir/$pidFileName"
}

# Prints an absolute path if found
ResolveInPath() {
    path=$1
    target=$2

    if ValidExecutable "$target"; then
        printf "$target"
        return
    fi
    OLDIFS=$IFS
    IFS=':'
    for filepath in $path; do
        res_task="$filepath/$target"
        if ValidExecutable "$res_task"; then
            printf "$res_task"
            IFS=$OLDIFS
            return
        fi
    done
    IFS=$OLDIFS
}

# Takes in an absolute path
#
# Return 0 if the file is a valid executable. Return nonzero otherwise
ValidExecutable() {
    target=$1

    if [ -f "$target" ]; then
        if [ -x "$target" ]; then
            return 0
        fi
    fi
    return 1
}

RunTasks() {
    tasks=$@

    for task in $tasks; do
        res_task=$(ResolveInPath "$SCAVENGERTASKPATH" "$task")
        if [ -z "$res_task" ]; then
            continue
        fi
        taskname=$(basename "$task")
        if RunSingleTask "$res_task" "$taskname"; then
            continue
        fi
        Announce 2 "ERROR: task $task aborted"
    done
}

RunSingleTask() {
    task=$1
    taskName=$2

    HuntingPrompt="{${taskName}}" $task
}
